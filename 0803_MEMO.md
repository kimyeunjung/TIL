# 알고리즘 1주차 - APS Python기본

##### 08-03-월



### 알고리즘

* 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법.

* 슈더코드와 순서도로 표현함.

* 무엇이 좋은 알고리즘인가?

  * 정확성
  * 작업량(얼마나 적은 연산으로 결과를 얻는가)
  * 메모리사용량(얼마나 적은 메모리를 사용하는가)
  * 단순성
  * 최적성(더 이상 개선할 여지없이 최적화되었는가)

* 시간 복잡도(Time Complexity)

  * 실행되는 명령문의 개수를 계산.

* 빅-오 표기법

  * 가장 큰 영향력을 주는 n에 대한 항만을 표시. 계수는 생략.

    ```
    O( 3n + 2) = O(3n) = O(n)
    		#최고차항만 선택 #계수 3 제거
    ```



### 배열

#### 1차원 배열

* Arr = list()
* Arr []
* Arr[0] = 10; 배열Arr의 0번째 원소에 10을 저장해라.
* Arr[idx] = 20; 배열Arr의 idx번째 원소에 20을 저장해라.
* 예제) Gravity, Baby-gin Game



### 완전검색

* 문제의 해법으로 생각되는 모든 경우의 수를 나열하고 확인하는 기법.
* Exaustive Search == Brute-force == generate and test기법
* 모든 경우의 수를 테스트 후, 최종 해법 도출.(수행속도가 느리나, 해답을 찾을 확률 높다.)
* 일반적으로 경우의 수가 상대적으로 작을 때 유용함.
* 예제)Baby-gin 접근



### 순열

* 서로 다른 것들 중 몇 개를 뽑아 한 줄로 나열하는 것.

* 서로 다른 n개 중 r개를 택하는 순열 `nPr = n * (n-1) * ...*(n-r+1)`

* `nPn = n ! = n * (n-1) * ... * 2*1`

  ```python
  for i1 in range(1, 4):
      for i2 in range(1, 4):
          if i2 != i1 :
              for i3 in range(1, 4):
                  if i3 != i1 and i3 != i2 :
                  	print(i1, i2, i3)
  ```

  

IM시험에서는 for문을 주로 쓴다.

for의 단계는 3가지로 이뤄짐. 

for 초기화- 검사 -증감:

​	실행

### 탐욕 알고리즘

* 최적해를 구하는 데 사용되는 근시안적인 방법
* 대부분의 알고리즘문제가 최적해를 구하는 방식이다.
* 여러 경우 중 하나를 결정할 때 그 순간에 최적이라고 생각되는 것을 선택.
* 각 선택의 시점에서 이뤄진 결정은 지역적으로는 최적이나,  그 선택들을 계속 수집하여 최종적인 해답을 만들었다하여, 그것이 최적이라는 보장은 없다.

* 1) 해 선택

  2) 실행가능성검사

  3)해 검사. 전체 문제의 해가 미완성 시,  1부터 다시 시작.

* 예) 거스름돈 줄이기



### 정렬

* 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값 또는 그 반대로 재배열 하는 것.

* 종류

  * 버블정렬/ 카운팅정렬/ 선택정렬/ 퀵정렬/ 삽입정렬/ 병합정렬

* 버블정렬

  * 인접한 두 원소를 비교하며 자리를 계속 교환하는 방식.

  * 첫 번째부터 인접한 원소끼리 계속 자리를 교환하며 맨 마지막까지 이동.

  * 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬됨.

  * 시간복잡도: O(n^2)

  * ```python
    def BubbleSort(a):
        for i in range(len(a)-1, 0, -1)#범위의 끝 위치
        	for j in range(0, i):
                if a[j] > a[j+1]:
                    a[j], a[j+1] = a[j+1], a[j] 
    ```

* 카운팅 정렬

  * 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형시간에 정렬하는 효율적인 알고리즘
  * 정수나 정수로 표현가능한 자료에 대해서만 적용가능. 집합 내 가장 큰 정수 알아야함.
  * 시간복잡도: O(n + k):n은 리스트길이, k는 정수의 최대값
  * 

베이비진 순열로 풀어보기

