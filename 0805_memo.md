# 2차원 배열

* 1차원 리스트를 묶어놓은 리스트
* 

```python
sum_v= 0
for i in range(len(arr)):
    for j in range(len(arr[i])):
        sum_v += arr[i][j]
print(sum_v)
```



* delta ; 원하는 순서대로 2차원 배열을 순회하기 위해 사용

* 상하좌우 순서로 접근할 수 있는 델다

  ```python
  dr = [0,0,0,0]	#row의 변화량
  dc = [0,0,0,0]	#column의 변화량
  	c0	  c1	c2
  r0 [0,0] [0,1] [0,2]
  r1 [1,0] [1,1] [1,2]
  r2 [2,0] [2,1] [2,2]
  [1][2][3]
  [4][5][6]
  [7][8][9]
  r3  
  arr = [[1,2,3],[4,5,6],[7,8,9]]
  r = 1
  c = 1
  c += dc[2]
  print(arr[r][c])
  상하좌우 연속으로 순회하기
  for i in range(4):
      #다음 좌표를 계산
      nr = r + dr[i] #다음위치
      nc = c + dc[i]
      print(print(arr[nr][nc]))#다음좌표값
      
  sum_v = 0
  for i in range(4):
  	nr = r + dr[i]
  	nc = c + dc[i]
  	sum_v += arr[nr][nc]
  print(sum_v)
  #팔방 순회 순서는 12시방향부터 시계방향으로 순회하면서 출력
  #2 3 6 9 8 7 4 1
  ```

  

#### 비트연산자로 멱집합 = power set 구하기

* 멱집합 = 모든 부분집합

  원소가 3개인 집합의 모든 부분집합의 개수

  각각의 원소가 2 개의 경우의 수를 가짐 (포함되거나 안되거나)

  2 * 2 * 2 = 8 = 2^3

* 1을 비트로 표현하면 0001

  비트를 왼쪽으로 하나 옮기면 0010 = 2

  한번 더 옮기면 0100 = 4

  한번 더 옮기면 1000 = 8

  1을  N번 왼쪽으로 옮기는 비트연산하면, 원소개수가 N인 집합의 부분집합개수와 같다.

* ```python
  0000
  0001
  0010
  0011
  0100
  0101
  0110
  0111
  1000
  각각 비트가 arr의 원소를 포함할지 안할지 결정하는 역할
  해당 비트가 0이면 원소포함하지않음
  1이면 원소포함하는 부분집합으로 판단.
  ```

* ```python
  # 0~7까지 증가하면서 각 비트를 이용해 부분집합 생성 
  n = 3
  #모든 부분집합
  # i의 비트 000
  for i in range(1<<n):	#8번 반복#1을 왼쪽으로 n번 밀어냄
      #i의 비트가 1인지 0인지 판단해야함.
      
      #부분집합 모양판단
      for j in range(n):
          #각각의 원소가 포함될지 안될지 비트랑 비교.
          if  i & (1<<j): 
              # &연산의 결과가 0이 아닌 무언가 >> 해당비트는 포함
              print(arr[j],end=" ")
      print()
  ```

* 

